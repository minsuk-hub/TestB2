/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package urlconnect;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;

public class App {
  private static void logError(String messg, Exception e) {
    System.err.println(messg);
    e.printStackTrace(System.err);
  }

  private static Optional<String> doGet(String target) {
    BufferedReader reader = null;

    try {
      URL url = new URL(target);
      HttpURLConnection connection = (HttpURLConnection) url.openConnection();
      connection.setRequestMethod("GET");
      connection.setReadTimeout(10 * 1000); // 10 sec
      connection.connect();

      reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));

      StringBuilder stringBuilder = new StringBuilder();
      String line;
      while ((line = reader.readLine()) != null) {
        stringBuilder.append(line).append("\n");
      }
      return Optional.of(stringBuilder.toString());
    } catch (Exception e) {
      logError("Failed to Get url: " + target, e);
      return Optional.empty();
    } finally {
      if (reader != null) {
        try {
          reader.close();
        } catch (IOException ioe) {
          logError("Failed to close buffered reader", ioe);
        }
      }
    }
  }

  private static final class PriceList {
    public final long totalRecords;
    public final Pricing[] data;

    public PriceList(long totalRecords, Pricing[] data) {
      this.totalRecords = totalRecords;
      this.data = data;
    }
  }

  private static final class HoldingList {
    public final long totalRecords;
    public final Holding[] data;

    public HoldingList(long totalRecords, Holding[] data) {
      this.totalRecords = totalRecords;
      this.data = data;
    }
  }

  private static final class Pricing {
    public final String date;
    public final String security;
    public final double price;

    public Pricing(String date, String security, double price) {
      this.date = date;
      this.security = security;
      this.price = price;
    }
  }

  private static final class Holding {
    public final String date;
    public final String security;
    public final double quantity;

    public Holding(String date, String security, double quantity) {
      this.date = date;
      this.security = security;
      this.quantity = quantity;
    }
  }

  private static List<Pricing> getPrices(String date) {
    Optional<PriceList> allPrices =
        doGet("https://api.myjson.com/bins/vf9ac").map(App::parsePrices);

    return allPrices
        .map(
            priceList ->
                Arrays.stream(priceList.data)
                    .filter(p -> date.equals(p.date))
                    .collect(Collectors.toList()))
        .orElse(Collections.emptyList());
  }

  private static PriceList parsePrices(String json) {
    Gson gson = new GsonBuilder().create();
    return gson.fromJson(json, PriceList.class);
  }

  private static List<Holding> getHoldings(String date) {
    Optional<HoldingList> allHoldings =
        doGet("https://api.myjson.com/bins/1eleys").map(App::parseHoldings);

    return allHoldings
        .map(
            holdingList ->
                Arrays.stream(holdingList.data)
                    .filter(p -> date.equals(p.date))
                    .collect(Collectors.toList()))
        .orElse(Collections.emptyList());
  }

  private static HoldingList parseHoldings(String json) {
    Gson gson = new GsonBuilder().create();
    return gson.fromJson(json, HoldingList.class);
  }

  public static double calculateHoldingValue(String date) {
    List<Holding> holdings = getHoldings(date);

    if (!holdings.isEmpty()) {
      Map<String, Double> pricings =
          getPrices(date).stream().collect(Collectors.toMap(p -> p.security, p -> p.price));

      return holdings.stream()
          .reduce(
              0.0,
              (sum, h) -> sum + h.quantity * pricings.getOrDefault(h.security, 0.0),
              Double::sum);
    }
    return 0.0;
  }

  public static void main(String[] args) {
    System.out.println(calculateHoldingValue("20190506"));
  }
}
